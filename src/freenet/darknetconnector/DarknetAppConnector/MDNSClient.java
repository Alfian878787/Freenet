package freenet.darknetconnector.DarknetAppConnector;

/**
 * A helper class with  methods to start and stop MDNS Discovery
 * If a broadcast is discovered, it verifies the sign and sends data to the MDNSReceiver
 * @author Illutionist 
 */

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.UnknownHostException;
import java.util.Enumeration;
import java.util.Timer;

import javax.jmdns.JmDNS;
import javax.jmdns.ServiceEvent;
import javax.jmdns.ServiceListener;

import android.content.Context;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.Handler;
import android.util.Log;


public class MDNSClient {
	protected static final String TAG = "MDNSClient";
	WifiManager.MulticastLock lock;
	Handler handler = new android.os.Handler();
	private String type = "_darknetAppServer._tcp.local.";
    private JmDNS jmdns = null;
    private ServiceListener listener = null;
    private Context context;
    private WifiManager wifi;
	public static Timer timer;
    public MDNSClient(Context context) {
    	this.context = context;
    	wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
        lock = wifi.createMulticastLock("lock");
        lock.setReferenceCounted(true);
        timer = new Timer();
	}
    
    public void startListening() {
    	//Start a thread that listens asynchronously for MDNS broadcasts
    	new AsynchronousExecutor().execute(jmdns); 	
    }
    
    public void stopListening() {
    	if (jmdns != null) {
            if (listener != null) {
                jmdns.removeServiceListener(type, listener);
                listener = null;
            }
            jmdns.unregisterAllServices();
            try {
                jmdns.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            jmdns = null;
    	}
        lock.release();
    }
    
    public boolean isListening() {
    	return !(listener==null);
    }
	class AsynchronousExecutor extends AsyncTask<JmDNS, Void,JmDNS> {
    	private String tetherScope = "";
        private byte[] int2Bytes(int IP) {
			byte[] inetBytes = new byte[] {
					(byte) (IP & 0xff),
					(byte) (IP >> 8 & 0xff),
					(byte) (IP >> 16 & 0xff),
					(byte) (IP >> 24 & 0xff)
			};
			return inetBytes;
        }
        /*
         * Listen for MDNS broadcasts. If we get hold of a broadcast check for signature
         * If signature matches, raise Intent through MDNSReceiver Class
         * TODO: Verify if the name contains Freenet. If it doesn't ignore the broadcast instead of signature verification
         * TODO: Exception Handling
         * @see android.os.AsyncTask#doInBackground(Params[])
         */
		@Override
		protected JmDNS doInBackground(JmDNS... params) {
				 WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);

				 WifiInfo connectionInfo = wifiManager.getConnectionInfo();
					if(connectionInfo == null) {
						listener = null;
						return null;
					}

					int WiFiIP = connectionInfo.getIpAddress();
					InetAddress myAddress;
					try {
					myAddress = InetAddress.getByAddress(int2Bytes(WiFiIP));
					Log.d(MDNSClient.TAG,myAddress.getHostAddress());
					if (myAddress.getHostAddress().equals("0.0.0.0")) {
						// We are not connected by wifi
						// Check tethered networks
						Enumeration en = NetworkInterface.getNetworkInterfaces();
						boolean done = false;
						while(en.hasMoreElements()) {
							NetworkInterface ni = (NetworkInterface)en.nextElement();
			                Enumeration en2 = ni.getInetAddresses();
			                InetAddress ia;
			                while (en2.hasMoreElements()) {
			                	ia = (InetAddress)en2.nextElement();
			                	// Assuming a link local address is generated by tether
			                	// Tested on two mobiles running normal background apps
			                	// Link local is most likely generated by tethering
			                    if (ia.isLinkLocalAddress()) {
			                        String[] split = ia.getHostAddress().split("%");
			                        if (split.length != 2) continue;
			                        tetherScope = "%" + split[1];
			                        myAddress = ia;	
			                        done = true;
			                        break;
			                    }
			                }
			                if (done) break;
						}
					}
					lock = wifi.createMulticastLock("lock");
			        lock.setReferenceCounted(true);
					lock.acquire();
					jmdns = JmDNS.create(myAddress);
					}
					catch (UnknownHostException e) {
						//Ignore as of now
						Log.d(MDNSClient.TAG,"Unknown Host - jmdns not created");
					} catch (IOException e) {
						//Ignore as of now
						Log.d(MDNSClient.TAG,"IOException - jmdns not created");
					}
					if (jmdns==null) {
						Log.d(MDNSClient.TAG,"jmdns not created");
						return null;
					}
		            jmdns.addServiceListener(type, listener = new ServiceListener() {

		                @Override
		                public void serviceResolved(ServiceEvent ev) {
		                	Log.d(MDNSClient.TAG,"An MDNS service claiming as " + type +" has been resolved");
		                    String additions = "";
		                    if (ev.getInfo().getInetAddresses() != null && ev.getInfo().getInetAddresses().length > 0) {
		                        additions = ev.getInfo().getInetAddresses()[0].getHostAddress();
		                    }
		                    byte[] signal = ev.getInfo().getTextBytes();  // This contains the publickey, signature and a pointer
		                    byte[] signature = null;
		                    byte[] publickey = null;
		                    byte[] pinBytes = null;
		                    int signEndPointer = signal[signal.length-2]*16 + signal[signal.length-1];
		                    int pubkeyEndPointer = signal[signal.length-4]*16 + signal[signal.length-3];
		                    signature = new byte[signEndPointer];
		                    publickey = new byte[pubkeyEndPointer-signEndPointer];
		                    pinBytes = new byte[signal.length-pubkeyEndPointer-4];
		                    for (int i=0;i!=signEndPointer;i++) {
		                        signature[i] = signal[i];
		                    }
		                    for (int i=signEndPointer;i!=pubkeyEndPointer;i++) {
		                        publickey[i-signEndPointer] = signal[i];
		                    }
		                    for (int i=pubkeyEndPointer;i!=signal.length-4;i++) {
		                        pinBytes[i-pubkeyEndPointer] = signal[i];
		                    }
		                    String pin = "";
							try {
								pin = new String(pinBytes,"UTF-8");
								Log.d(MDNSClient.TAG,"pin  "+pin);
							} catch (UnsupportedEncodingException e) {
								e.printStackTrace();
							}
							String data2verify = ev.getInfo().getName()+pin;
							Log.d(MDNSClient.TAG,data2verify);
							boolean verification = ECDSA.verify(data2verify, signature, publickey);
							Log.d(MDNSClient.TAG,"Verification Result "+ Boolean.toString(verification));
							String[] split = pin.split("pin -=");
							String[] splite = split[1].split("=-");
							pin = splite[0];
							String ip = additions + tetherScope;
		                    if (verification)  {
		                    	MDNSReceiver rec = new MDNSReceiver(ev.getInfo().getName(),ip,ev.getInfo().getPort(),pin);
								rec.start();
		                    }
		                }

		                @Override
		                public void serviceRemoved(ServiceEvent ev) {
		                	// Doing nothing
		                }

		                @Override
		                public void serviceAdded(ServiceEvent event) {
		                    // Initial Addition
		                    jmdns.requestServiceInfo(event.getType(), event.getName(), 1);
		                }
		            });

			return jmdns;
		}
		 protected void onPostExecute(JmDNS params) {
			 	//Do Nothing
	        }
		 
     }
    
    
}
